{
  "version": 3,
  "sources": ["../../../src/components/dx-style-x.ts"],
  "sourcesContent": ["class xDomStyle extends HTMLElement {\n  styleSheet: CSSStyleSheet = new CSSStyleSheet();\n  constructor() {\n    super();\n    this.attachShadow({ mode: \"open\" });\n    this.shadowRoot!.innerHTML = `<slot></slot>`;\n    this.render = this.render.bind(this);\n    this.renderStyle = this.renderStyle.bind(this);\n    this.shadowRoot!.adoptedStyleSheets = [this.styleSheet];\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.type === \"attributes\") this.render();\n        if (mutation.type === \"childList\")\n          this.renderStyle(mutation.addedNodes);\n      });\n    });\n    observer.observe(this, { attributes: true, childList: true });\n  }\n  connectedCallback() {\n    window.addEventListener(\"resize\", this.render);\n  }\n  disconnectedCallback() {\n    window.removeEventListener(\"resize\", this.render);\n  }\n  render() {\n    this.renderStyle(this.shadowRoot!.childNodes);\n    // apply to host to protect from inheritance\n    this.styleSheet.replace(`:host { display:inherit; }`);\n  }\n  renderStyle(nodes: NodeList) {\n    let currentNode = 1;\n    nodes.forEach((node) => {\n      if (!(node instanceof HTMLElement)) return;\n\n      const isDxElement = (node as any).tagName?.startsWith(\"DX-\");\n      // If this is a dx component, pass along the attributes\n      if (isDxElement) {\n        return this.getAttributeNames().forEach((attributeName) => {\n          node.setAttribute(attributeName, this.getAttribute(attributeName)!);\n        });\n      } else {\n        console.log(node, currentNode);\n        let styles: string[][] = [];\n        let psuedoStyles: Record<string, [string, string][]> = {};\n        this.getAttributeNames().forEach((attributeName) => {\n          const [style, bp] = attributeName.split(\"__\");\n          const [attr, psuedo] = style.split(\":\");\n          const breakpoint = Number(bp ?? 0);\n          if (window.innerWidth < breakpoint) return;\n          const value = (this as any).getAttribute(attributeName);\n          if (psuedo) {\n            if (!psuedoStyles[psuedo]) psuedoStyles[psuedo] = [];\n            psuedoStyles[psuedo].push([attr, value]);\n          } else {\n            styles.push([attr, value]);\n          }\n        });\n\n        // generate host styles\n        const hostStyles = `::slotted(:nth-child(${currentNode})) { ${styles\n          .map(([attr, value]) => `${attr}:${value};`)\n          .join(\"\")}}`;\n\n        // generate host psuedo styles\n        const hostPsuedoStyles = Object.entries(psuedoStyles)\n          .map(([psuedo, styles]) => {\n            const _styles = styles\n              .map(([attr, value]) => `${attr}:${value};`)\n              .join(\"\");\n            return `::slotted(:nth-child(${currentNode}):${psuedo}) { ${_styles} }`;\n          })\n          .join(\"\");\n\n        this.styleSheet.insertRule(hostStyles);\n        this.styleSheet.insertRule(hostPsuedoStyles);\n      }\n\n      currentNode++;\n    });\n  }\n  // renderStyle(nodes: NodeList) {\n  //   let currentNode = 1;\n  //   nodes.forEach((node) => {\n  //     if (!(node instanceof HTMLElement)) return;\n\n  //     const isDxElement = (node as any).tagName?.startsWith(\"DX-\");\n  //     // If this is a dx component, pass along the attributes\n  //     if (isDxElement) {\n  //       return this.getAttributeNames().forEach((attributeName) => {\n  //         node.setAttribute(attributeName, this.getAttribute(attributeName)!);\n  //       });\n  //     } else {\n  //       console.log(node, currentNode);\n  //       let styles: string[][] = [];\n  //       let psuedoStyles: Record<string, [string, string][]> = {};\n  //       this.getAttributeNames().forEach((attributeName) => {\n  //         const [style, bp] = attributeName.split(\"__\");\n  //         const [attr, psuedo] = style.split(\":\");\n  //         const breakpoint = Number(bp ?? 0);\n  //         if (window.innerWidth < breakpoint) return;\n  //         const value = (this as any).getAttribute(attributeName);\n  //         if (psuedo) {\n  //           if (!psuedoStyles[psuedo]) psuedoStyles[psuedo] = [];\n  //           psuedoStyles[psuedo].push([attr, value]);\n  //         } else {\n  //           styles.push([attr, value]);\n  //         }\n  //       });\n\n  //       // generate host styles\n  //       const hostStyles = `::slotted(:nth-child(${currentNode})) { ${styles\n  //         .map(([attr, value]) => `${attr}:${value};`)\n  //         .join(\"\")}}`;\n\n  //       // generate host psuedo styles\n  //       const hostPsuedoStyles = Object.entries(psuedoStyles)\n  //         .map(([psuedo, styles]) => {\n  //           const _styles = styles\n  //             .map(([attr, value]) => `${attr}:${value};`)\n  //             .join(\"\");\n  //           return `::slotted(:nth-child(${currentNode}):${psuedo}) { ${_styles} }`;\n  //         })\n  //         .join(\"\");\n\n  //       this.styleSheet.insertRule(hostStyles);\n  //       this.styleSheet.insertRule(hostPsuedoStyles);\n  //     }\n\n  //     currentNode++;\n  //   });\n  // }\n}\n\ncustomElements.define(\"dx-style\", xDomStyle);\n"],
  "mappings": "mBAAA,IAAMA,EAAN,cAAwB,WAAY,CAElC,aAAc,CACZ,MAAM,EAFR,gBAA4B,IAAI,cAG9B,KAAK,aAAa,CAAE,KAAM,MAAO,CAAC,EAClC,KAAK,WAAY,UAAY,gBAC7B,KAAK,OAAS,KAAK,OAAO,KAAK,IAAI,EACnC,KAAK,YAAc,KAAK,YAAY,KAAK,IAAI,EAC7C,KAAK,WAAY,mBAAqB,CAAC,KAAK,UAAU,EACrC,IAAI,iBAAkBC,GAAc,CACnDA,EAAU,QAASC,GAAa,CAC1BA,EAAS,OAAS,cAAc,KAAK,OAAO,EAC5CA,EAAS,OAAS,aACpB,KAAK,YAAYA,EAAS,UAAU,CACxC,CAAC,CACH,CAAC,EACQ,QAAQ,KAAM,CAAE,WAAY,GAAM,UAAW,EAAK,CAAC,CAC9D,CACA,mBAAoB,CAClB,OAAO,iBAAiB,SAAU,KAAK,MAAM,CAC/C,CACA,sBAAuB,CACrB,OAAO,oBAAoB,SAAU,KAAK,MAAM,CAClD,CACA,QAAS,CACP,KAAK,YAAY,KAAK,WAAY,UAAU,EAE5C,KAAK,WAAW,QAAQ,4BAA4B,CACtD,CACA,YAAYC,EAAiB,CAC3B,IAAIC,EAAc,EAClBD,EAAM,QAASE,GAAS,CACtB,GAAI,EAAEA,aAAgB,aAAc,OAIpC,GAFqBA,EAAa,SAAS,WAAW,KAAK,EAGzD,OAAO,KAAK,kBAAkB,EAAE,QAASC,GAAkB,CACzDD,EAAK,aAAaC,EAAe,KAAK,aAAaA,CAAa,CAAE,CACpE,CAAC,EACI,CACL,QAAQ,IAAID,EAAMD,CAAW,EAC7B,IAAIG,EAAqB,CAAC,EACtBC,EAAmD,CAAC,EACxD,KAAK,kBAAkB,EAAE,QAASF,GAAkB,CAClD,GAAM,CAACG,EAAOC,CAAE,EAAIJ,EAAc,MAAM,IAAI,EACtC,CAACK,EAAMC,CAAM,EAAIH,EAAM,MAAM,GAAG,EAChCI,EAAa,OAAOH,GAAM,CAAC,EACjC,GAAI,OAAO,WAAaG,EAAY,OACpC,IAAMC,EAAS,KAAa,aAAaR,CAAa,EAClDM,GACGJ,EAAaI,KAASJ,EAAaI,GAAU,CAAC,GACnDJ,EAAaI,GAAQ,KAAK,CAACD,EAAMG,CAAK,CAAC,GAEvCP,EAAO,KAAK,CAACI,EAAMG,CAAK,CAAC,CAE7B,CAAC,EAGD,IAAMC,EAAa,wBAAwBX,SAAmBG,EAC3D,IAAI,CAAC,CAACI,EAAMG,CAAK,IAAM,GAAGH,KAAQG,IAAQ,EAC1C,KAAK,EAAE,KAGJE,EAAmB,OAAO,QAAQR,CAAY,EACjD,IAAI,CAAC,CAACI,EAAQL,CAAM,IAAM,CACzB,IAAMU,EAAUV,EACb,IAAI,CAAC,CAACI,EAAMG,CAAK,IAAM,GAAGH,KAAQG,IAAQ,EAC1C,KAAK,EAAE,EACV,MAAO,wBAAwBV,MAAgBQ,QAAaK,KAC9D,CAAC,EACA,KAAK,EAAE,EAEV,KAAK,WAAW,WAAWF,CAAU,EACrC,KAAK,WAAW,WAAWC,CAAgB,CAC7C,CAEAZ,GACF,CAAC,CACH,CAoDF,EAEA,eAAe,OAAO,WAAYJ,CAAS",
  "names": ["xDomStyle", "mutations", "mutation", "nodes", "currentNode", "node", "attributeName", "styles", "psuedoStyles", "style", "bp", "attr", "psuedo", "breakpoint", "value", "hostStyles", "hostPsuedoStyles", "_styles"]
}
